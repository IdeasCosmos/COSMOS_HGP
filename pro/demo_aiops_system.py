#!/usr/bin/env python3
"""
COSMOS AIOps Îç∞Î™® ÏãúÏä§ÌÖú
Î°úÍ∑∏ ÏûÖÎ†• ‚Üí Í≤ΩÎ≥¥ ÏÜåÏùå ÏñµÏ†ú ‚Üí 3WHY ÏÑ§Î™Ö Ï∂úÎ†•
"""

import numpy as np
import time
import json
import random
from typing import Dict, List, Any, Optional
from dataclasses import dataclass
from datetime import datetime, timedelta
import logging

# COSMOS Ïª¥Ìè¨ÎÑåÌä∏ import (Ïã§Ï†úÎ°úÎäî Î™®ÎìàÏóêÏÑú Í∞ÄÏ†∏Ïò¥)
try:
    from extended_rules import ExtendedRuleSet, DomainType, CodonType
    from core.velocity import VelocityManager
    from core.engine import UnifiedCosmosEngine
except ImportError:
    # ÏûÑÏãú Íµ¨ÌòÑ
    from enum import Enum
    
    class DomainType(Enum):
        AIOPS = "aiops"
    
    class CodonType(Enum):
        AAT = ("AAT", "PARSE", "L1_QUANTUM", "ÌååÏã±")
        GCC = ("GCC", "PREDICT", "L2_ATOMIC", "ÏòàÏ∏°")
        CCT = ("CCT", "ALERT", "L4_COMPOUND", "ÏïåÎ¶º")

logger = logging.getLogger(__name__)

@dataclass
class LogEntry:
    """Î°úÍ∑∏ ÏóîÌä∏Î¶¨"""
    timestamp: str
    level: str
    component: str
    message: str
    metadata: Dict[str, Any] = None

@dataclass
class Alert:
    """Í≤ΩÎ≥¥"""
    id: str
    timestamp: str
    severity: str
    component: str
    message: str
    noise_level: float = 1.0
    confidence: float = 0.0
    root_cause: str = ""
    action_taken: str = ""

@dataclass
class WhyAnalysis:
    """3WHY Î∂ÑÏÑù Í≤∞Í≥º"""
    primary_why: str
    secondary_why: str
    tertiary_why: str
    root_cause: str
    confidence: float
    suggested_actions: List[str]

class COSMOSAIOpsDemo:
    """COSMOS AIOps Îç∞Î™® ÏãúÏä§ÌÖú"""
    
    def __init__(self):
        self.rule_set = ExtendedRuleSet()
        self.velocity_manager = None  # VelocityManager()
        self.engine = None  # UnifiedCosmosEngine()
        
        # ÏãúÎÆ¨Î†àÏù¥ÏÖò Îç∞Ïù¥ÌÑ∞
        self.log_entries: List[LogEntry] = []
        self.alerts: List[Alert] = []
        self.processed_logs: List[Dict] = []
        
        # ÌÜµÍ≥Ñ
        self.stats = {
            'logs_processed': 0,
            'alerts_generated': 0,
            'noise_reduced': 0,
            'false_positives': 0,
            'true_positives': 0
        }
    
    def generate_sample_logs(self, count: int = 100) -> List[LogEntry]:
        """ÏÉòÌîå Î°úÍ∑∏ ÏÉùÏÑ±"""
        components = ['web-server', 'database', 'cache', 'api-gateway', 'load-balancer']
        levels = ['INFO', 'WARN', 'ERROR', 'DEBUG']
        
        base_time = datetime.now() - timedelta(hours=1)
        
        logs = []
        for i in range(count):
            # Ïã§Ï†ú ÏãúÏä§ÌÖú Î°úÍ∑∏ Ìå®ÌÑ¥ ÏãúÎÆ¨Î†àÏù¥ÏÖò
            component = random.choice(components)
            level = random.choices(levels, weights=[60, 20, 15, 5])[0]
            
            if component == 'database' and level == 'ERROR':
                message = "Connection pool exhausted. Retrying..."
            elif component == 'web-server' and level == 'WARN':
                message = "Response time exceeded threshold: 2000ms"
            elif component == 'api-gateway' and level == 'ERROR':
                message = "Rate limit exceeded for user session"
            else:
                messages = [
                    f"Processing request {random.randint(1000, 9999)}",
                    f"Cache hit rate: {random.randint(70, 95)}%",
                    f"Memory usage: {random.randint(60, 85)}%",
                    f"CPU usage: {random.randint(40, 90)}%"
                ]
                message = random.choice(messages)
            
            log = LogEntry(
                timestamp=(base_time + timedelta(minutes=i)).isoformat(),
                level=level,
                component=component,
                message=message,
                metadata={
                    'request_id': f"req_{random.randint(10000, 99999)}",
                    'user_id': f"user_{random.randint(1000, 9999)}" if random.random() > 0.5 else None
                }
            )
            logs.append(log)
        
        return logs
    
    def parse_logs(self, logs: List[LogEntry]) -> List[Dict]:
        """1Îã®Í≥Ñ: Î°úÍ∑∏ ÌååÏã± Î∞è Î∂ÑÏÑù"""
        print("üîç 1Îã®Í≥Ñ: Î°úÍ∑∏ ÌååÏã± Î∞è Î∂ÑÏÑù")
        print("-" * 40)
        
        parsed_logs = []
        
        for log in logs:
            # COSMOS Í∑úÏπô Ï†ÅÏö©
            parsed = self._apply_parsing_rules(log)
            parsed_logs.append(parsed)
            
            print(f"üìù {log.timestamp} [{log.level}] {log.component}: {log.message[:50]}...")
        
        self.processed_logs = parsed_logs
        self.stats['logs_processed'] = len(parsed_logs)
        
        print(f"\n‚úÖ Ï¥ù {len(parsed_logs)}Í∞ú Î°úÍ∑∏ ÌååÏã± ÏôÑÎ£å")
        return parsed_logs
    
    def _apply_parsing_rules(self, log: LogEntry) -> Dict:
        """ÌååÏã± Í∑úÏπô Ï†ÅÏö©"""
        # Í∞ÑÎã®Ìïú ÌååÏã± Î°úÏßÅ (Ïã§Ï†úÎ°úÎäî COSMOS Í∑úÏπô ÏÇ¨Ïö©)
        parsed = {
            'original': log,
            'timestamp': log.timestamp,
            'level': log.level,
            'component': log.component,
            'message': log.message,
            'parsed': True,
            'patterns': [],
            'anomaly_score': 0.0
        }
        
        # Ìå®ÌÑ¥ Ï∂îÏ∂ú
        if 'error' in log.message.lower():
            parsed['patterns'].append('error_pattern')
            parsed['anomaly_score'] += 0.3
        if 'timeout' in log.message.lower():
            parsed['patterns'].append('timeout_pattern')
            parsed['anomaly_score'] += 0.4
        if 'connection' in log.message.lower():
            parsed['patterns'].append('connection_pattern')
            parsed['anomaly_score'] += 0.2
        if log.level == 'ERROR':
            parsed['anomaly_score'] += 0.5
        elif log.level == 'WARN':
            parsed['anomaly_score'] += 0.2
        
        return parsed
    
    def detect_anomalies(self, parsed_logs: List[Dict]) -> List[Dict]:
        """2Îã®Í≥Ñ: Ïù¥ÏÉÅ ÌÉêÏßÄ"""
        print("\nüö® 2Îã®Í≥Ñ: Ïù¥ÏÉÅ ÌÉêÏßÄ")
        print("-" * 40)
        
        anomalies = []
        
        # Ïª¥Ìè¨ÎÑåÌä∏Î≥Ñ Î°úÍ∑∏ Í∑∏Î£πÌôî
        component_logs = {}
        for log in parsed_logs:
            component = log['component']
            if component not in component_logs:
                component_logs[component] = []
            component_logs[component].append(log)
        
        # Í∞Å Ïª¥Ìè¨ÎÑåÌä∏Î≥Ñ Ïù¥ÏÉÅ ÌÉêÏßÄ
        for component, logs in component_logs.items():
            component_anomalies = self._detect_component_anomalies(component, logs)
            anomalies.extend(component_anomalies)
        
        print(f"üîç {len(anomalies)}Í∞ú Ïù¥ÏÉÅ Ìå®ÌÑ¥ ÌÉêÏßÄ")
        for anomaly in anomalies:
            print(f"   ‚Ä¢ {anomaly['component']}: {anomaly['type']} (Ï†êÏàò: {anomaly['score']:.2f})")
        
        return anomalies
    
    def _detect_component_anomalies(self, component: str, logs: List[Dict]) -> List[Dict]:
        """Ïª¥Ìè¨ÎÑåÌä∏Î≥Ñ Ïù¥ÏÉÅ ÌÉêÏßÄ"""
        anomalies = []
        
        # ÏóêÎü¨ ÎπàÎèÑ Î∂ÑÏÑù
        error_logs = [log for log in logs if log['level'] == 'ERROR']
        if len(error_logs) > 5:  # ÏûÑÍ≥ÑÍ∞í
            anomalies.append({
                'component': component,
                'type': 'high_error_rate',
                'score': min(1.0, len(error_logs) / len(logs)),
                'details': f"{len(error_logs)}Í∞ú ÏóêÎü¨ Î°úÍ∑∏ Î∞úÍ≤¨",
                'timestamp': logs[-1]['timestamp']
            })
        
        # ÏãúÍ∞Ñ Í∞ÑÍ≤© Î∂ÑÏÑù (Ïó∞ÏÜç ÏóêÎü¨)
        consecutive_errors = 0
        max_consecutive = 0
        for log in logs:
            if log['level'] == 'ERROR':
                consecutive_errors += 1
                max_consecutive = max(max_consecutive, consecutive_errors)
            else:
                consecutive_errors = 0
        
        if max_consecutive > 3:
            anomalies.append({
                'component': component,
                'type': 'consecutive_errors',
                'score': min(1.0, max_consecutive / 10),
                'details': f"Ïó∞ÏÜç {max_consecutive}Í∞ú ÏóêÎü¨",
                'timestamp': logs[-1]['timestamp']
            })
        
        # Ïù¥ÏÉÅ Ï†êÏàò Í∏∞Î∞ò ÌÉêÏßÄ
        high_anomaly_logs = [log for log in logs if log['anomaly_score'] > 0.7]
        if len(high_anomaly_logs) > 0:
            avg_score = np.mean([log['anomaly_score'] for log in high_anomaly_logs])
            anomalies.append({
                'component': component,
                'type': 'high_anomaly_score',
                'score': avg_score,
                'details': f"ÌèâÍ∑† Ïù¥ÏÉÅ Ï†êÏàò: {avg_score:.2f}",
                'timestamp': logs[-1]['timestamp']
            })
        
        return anomalies
    
    def generate_alerts(self, anomalies: List[Dict]) -> List[Alert]:
        """3Îã®Í≥Ñ: Í≤ΩÎ≥¥ ÏÉùÏÑ±"""
        print("\nüì¢ 3Îã®Í≥Ñ: Í≤ΩÎ≥¥ ÏÉùÏÑ±")
        print("-" * 40)
        
        alerts = []
        
        for anomaly in anomalies:
            # Í≤ΩÎ≥¥ Ïã¨Í∞ÅÎèÑ Í≤∞Ï†ï
            if anomaly['score'] > 0.8:
                severity = 'CRITICAL'
            elif anomaly['score'] > 0.6:
                severity = 'HIGH'
            elif anomaly['score'] > 0.4:
                severity = 'MEDIUM'
            else:
                severity = 'LOW'
            
            # ÎÖ∏Ïù¥Ï¶à Î†àÎ≤® Í≥ÑÏÇ∞
            noise_level = self._calculate_noise_level(anomaly)
            
            alert = Alert(
                id=f"ALERT_{len(alerts)+1:04d}",
                timestamp=anomaly['timestamp'],
                severity=severity,
                component=anomaly['component'],
                message=f"{anomaly['type']}: {anomaly['details']}",
                noise_level=noise_level,
                confidence=anomaly['score']
            )
            
            alerts.append(alert)
            print(f"üö® {alert.id} [{alert.severity}] {alert.component}: {alert.message}")
        
        self.alerts = alerts
        self.stats['alerts_generated'] = len(alerts)
        
        print(f"\n‚úÖ Ï¥ù {len(alerts)}Í∞ú Í≤ΩÎ≥¥ ÏÉùÏÑ±")
        return alerts
    
    def _calculate_noise_level(self, anomaly: Dict) -> float:
        """ÎÖ∏Ïù¥Ï¶à Î†àÎ≤® Í≥ÑÏÇ∞"""
        base_noise = 1.0
        
        # Ïª¥Ìè¨ÎÑåÌä∏Î≥Ñ ÎÖ∏Ïù¥Ï¶à Í∞ÄÏ§ëÏπò
        component_weights = {
            'database': 0.3,  # Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§Îäî Ï§ëÏöîÌïòÎØÄÎ°ú ÎÇÆÏùÄ ÎÖ∏Ïù¥Ï¶à
            'api-gateway': 0.4,
            'web-server': 0.5,
            'cache': 0.7,     # Ï∫êÏãúÎäî ÏÉÅÎåÄÏ†ÅÏúºÎ°ú ÎÜíÏùÄ ÎÖ∏Ïù¥Ï¶à
            'load-balancer': 0.6
        }
        
        component = anomaly['component']
        weight = component_weights.get(component, 0.5)
        
        # Ïù¥ÏÉÅ Ï†êÏàòÏóê Îî∞Î•∏ Ï°∞Ï†ï
        score_factor = 1.0 - anomaly['score']  # Ï†êÏàòÍ∞Ä ÎÜíÏùÑÏàòÎ°ù ÎÖ∏Ïù¥Ï¶à ÎÇÆÏùå
        
        return base_noise * weight * score_factor
    
    def suppress_noise(self, alerts: List[Alert]) -> List[Alert]:
        """4Îã®Í≥Ñ: Í≤ΩÎ≥¥ ÏÜåÏùå ÏñµÏ†ú"""
        print("\nüîá 4Îã®Í≥Ñ: Í≤ΩÎ≥¥ ÏÜåÏùå ÏñµÏ†ú")
        print("-" * 40)
        
        # ÎÖ∏Ïù¥Ï¶à ÏñµÏ†ú Í∑úÏπô Ï†ÅÏö©
        suppressed_alerts = []
        suppressed_count = 0
        
        for alert in alerts:
            should_suppress = self._should_suppress_alert(alert, alerts)
            
            if should_suppress:
                alert.action_taken = "NOISE_SUPPRESSED"
                suppressed_count += 1
                print(f"üîá {alert.id} ÏÜåÏùå ÏñµÏ†ú (ÎÖ∏Ïù¥Ï¶à Î†àÎ≤®: {alert.noise_level:.2f})")
            else:
                suppressed_alerts.append(alert)
                print(f"‚úÖ {alert.id} Í≤ΩÎ≥¥ Ïú†ÏßÄ (ÎÖ∏Ïù¥Ï¶à Î†àÎ≤®: {alert.noise_level:.2f})")
        
        self.stats['noise_reduced'] = suppressed_count
        
        print(f"\n‚úÖ {suppressed_count}Í∞ú Í≤ΩÎ≥¥ ÏÜåÏùå ÏñµÏ†ú, {len(suppressed_alerts)}Í∞ú Í≤ΩÎ≥¥ Ïú†ÏßÄ")
        return suppressed_alerts
    
    def _should_suppress_alert(self, alert: Alert, all_alerts: List[Alert]) -> bool:
        """Í≤ΩÎ≥¥ ÏñµÏ†ú Ïó¨Î∂Ä Í≤∞Ï†ï"""
        # 1. ÎÖ∏Ïù¥Ï¶à Î†àÎ≤®Ïù¥ ÎÜíÏùÄ Í≤ΩÏö∞
        if alert.noise_level > 0.7:
            return True
        
        # 2. Í∞ôÏùÄ Ïª¥Ìè¨ÎÑåÌä∏ÏóêÏÑú ÏßßÏùÄ ÏãúÍ∞Ñ ÎÇ¥ Ïó¨Îü¨ Í≤ΩÎ≥¥ Î∞úÏÉù
        recent_alerts = [
            a for a in all_alerts 
            if a.component == alert.component and a.id != alert.id
        ]
        
        if len(recent_alerts) > 3:
            return True
        
        # 3. LOW Ïã¨Í∞ÅÎèÑÏù¥Í≥† ÎÖ∏Ïù¥Ï¶à Î†àÎ≤®Ïù¥ ÎÜíÏùÄ Í≤ΩÏö∞
        if alert.severity == 'LOW' and alert.noise_level > 0.5:
            return True
        
        return False
    
    def perform_3why_analysis(self, alert: Alert) -> WhyAnalysis:
        """5Îã®Í≥Ñ: 3WHY Î∂ÑÏÑù"""
        print(f"\nüîç 5Îã®Í≥Ñ: 3WHY Î∂ÑÏÑù - {alert.id}")
        print("-" * 40)
        
        # Ïª¥Ìè¨ÎÑåÌä∏Î≥Ñ 3WHY Î∂ÑÏÑù
        if alert.component == 'database':
            analysis = self._analyze_database_issue(alert)
        elif alert.component == 'api-gateway':
            analysis = self._analyze_api_gateway_issue(alert)
        elif alert.component == 'web-server':
            analysis = self._analyze_web_server_issue(alert)
        else:
            analysis = self._analyze_generic_issue(alert)
        
        print(f"1Ô∏è‚É£ Ïôú? {analysis.primary_why}")
        print(f"2Ô∏è‚É£ Ïôú? {analysis.secondary_why}")
        print(f"3Ô∏è‚É£ Ïôú? {analysis.tertiary_why}")
        print(f"üéØ Í∑ºÎ≥∏ ÏõêÏù∏: {analysis.root_cause}")
        print(f"üìä Ïã†Î¢∞ÎèÑ: {analysis.confidence:.2f}")
        
        if analysis.suggested_actions:
            print("üí° Í∂åÏû• Ï°∞Ïπò:")
            for action in analysis.suggested_actions:
                print(f"   ‚Ä¢ {action}")
        
        return analysis
    
    def _analyze_database_issue(self, alert: Alert) -> WhyAnalysis:
        """Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ Ïù¥Ïäà 3WHY Î∂ÑÏÑù"""
        if 'connection pool' in alert.message.lower():
            return WhyAnalysis(
                primary_why="Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ Ïó∞Í≤∞ ÌíÄÏù¥ Í≥†Í∞àÎê®",
                secondary_why="ÎèôÏãú Ïó∞Í≤∞ ÏàòÍ∞Ä ÏÑ§Ï†ïÎêú ÏµúÎåÄÍ∞íÏùÑ Ï¥àÍ≥ºÌï®",
                tertiary_why="Ïó∞Í≤∞ ÌíÄ ÌÅ¨Í∏∞Í∞Ä Î∂ÄÏ°±ÌïòÍ±∞ÎÇò Ïó∞Í≤∞Ïù¥ Ï†úÎåÄÎ°ú Ìï¥Ï†úÎêòÏßÄ ÏïäÏùå",
                root_cause="Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ Ïó∞Í≤∞ ÌíÄ ÏÑ§Ï†ï Î∂ÄÏ°± Î∞è Ïó∞Í≤∞ ÎàÑÏàò",
                confidence=0.85,
                suggested_actions=[
                    "Ïó∞Í≤∞ ÌíÄ ÌÅ¨Í∏∞ Ï¶ùÍ∞Ä (max_connections: 100 ‚Üí 200)",
                    "Ïó∞Í≤∞ ÌÉÄÏûÑÏïÑÏõÉ ÏÑ§Ï†ï ÏµúÏ†ÅÌôî",
                    "Ïó∞Í≤∞ ÎàÑÏàò Í≤ÄÏÇ¨ Î∞è ÏàòÏ†ï",
                    "Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ ÏÑ±Îä• Î™®ÎãàÌÑ∞ÎßÅ Í∞ïÌôî"
                ]
            )
        else:
            return self._analyze_generic_issue(alert)
    
    def _analyze_api_gateway_issue(self, alert: Alert) -> WhyAnalysis:
        """API Í≤åÏù¥Ìä∏Ïõ®Ïù¥ Ïù¥Ïäà 3WHY Î∂ÑÏÑù"""
        if 'rate limit' in alert.message.lower():
            return WhyAnalysis(
                primary_why="API ÏöîÏ≤≠ ÌïúÎèÑ Ï¥àÍ≥º",
                secondary_why="ÌäπÏ†ï ÏÇ¨Ïö©ÏûêÍ∞Ä ÏÑ§Ï†ïÎêú ÏöîÏ≤≠ Ï†úÌïúÏùÑ Ï¥àÍ≥ºÌï®",
                tertiary_why="ÎπÑÏ†ïÏÉÅÏ†ÅÏù∏ Ìä∏ÎûòÌîΩ Ìå®ÌÑ¥ ÎòêÎäî Î¥á Í≥µÍ≤©",
                root_cause="Rate limiting ÏÑ§Ï†ï Î∂ÄÏ°± Î∞è ÎπÑÏ†ïÏÉÅ Ìä∏ÎûòÌîΩ ÌÉêÏßÄ ÎØ∏Ìù°",
                confidence=0.80,
                suggested_actions=[
                    "Rate limiting Ï†ïÏ±Ö Ïû¨Í≤ÄÌÜ†",
                    "ÏÇ¨Ïö©ÏûêÎ≥Ñ ÏöîÏ≤≠ Ìå®ÌÑ¥ Î∂ÑÏÑù",
                    "DDoS Í≥µÍ≤© ÌÉêÏßÄ ÏãúÏä§ÌÖú Íµ¨Ï∂ï",
                    "API ÏÇ¨Ïö©Îüâ Î™®ÎãàÌÑ∞ÎßÅ ÎåÄÏãúÎ≥¥Îìú Íµ¨Ï∂ï"
                ]
            )
        else:
            return self._analyze_generic_issue(alert)
    
    def _analyze_web_server_issue(self, alert: Alert) -> WhyAnalysis:
        """Ïõπ ÏÑúÎ≤Ñ Ïù¥Ïäà 3WHY Î∂ÑÏÑù"""
        if 'response time' in alert.message.lower():
            return WhyAnalysis(
                primary_why="Ïõπ ÏÑúÎ≤Ñ ÏùëÎãµ ÏãúÍ∞Ñ Ï¥àÍ≥º",
                secondary_why="ÏÑúÎ≤Ñ Ï≤òÎ¶¨ Îä•Î†• Î∂ÄÏ°± ÎòêÎäî Ïô∏Î∂Ä ÏùòÏ°¥ÏÑ± ÏßÄÏó∞",
                tertiary_why="Î¶¨ÏÜåÏä§ Î∂ÄÏ°±, ÎπÑÌö®Ïú®Ï†ÅÏù∏ ÏøºÎ¶¨, ÎòêÎäî ÎÑ§Ìä∏ÏõåÌÅ¨ ÏßÄÏó∞",
                root_cause="ÏÑúÎ≤Ñ Î¶¨ÏÜåÏä§ Î∂ÄÏ°± Î∞è ÏÑ±Îä• ÏµúÏ†ÅÌôî ÎØ∏Ìù°",
                confidence=0.75,
                suggested_actions=[
                    "ÏÑúÎ≤Ñ Î¶¨ÏÜåÏä§ Î™®ÎãàÌÑ∞ÎßÅ Î∞è Ïä§ÏºÄÏùºÎßÅ",
                    "Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ ÏøºÎ¶¨ ÏµúÏ†ÅÌôî",
                    "Ï∫êÏã± Ï†ÑÎûµ Í∞úÏÑ†",
                    "Î°úÎìú Î∞∏Îü∞Ïã± ÏµúÏ†ÅÌôî"
                ]
            )
        else:
            return self._analyze_generic_issue(alert)
    
    def _analyze_generic_issue(self, alert: Alert) -> WhyAnalysis:
        """ÏùºÎ∞ò Ïù¥Ïäà 3WHY Î∂ÑÏÑù"""
        return WhyAnalysis(
            primary_why=f"{alert.component}ÏóêÏÑú {alert.severity} Î†àÎ≤® Ïù¥Ïäà Î∞úÏÉù",
            secondary_why="ÏãúÏä§ÌÖú Íµ¨ÏÑ± ÏöîÏÜåÏùò ÎπÑÏ†ïÏÉÅÏ†ÅÏù∏ ÎèôÏûë",
            tertiary_why="ÏÑ§Ï†ï Ïò§Î•ò, Î¶¨ÏÜåÏä§ Î∂ÄÏ°±, ÎòêÎäî Ïô∏Î∂Ä ÏùòÏ°¥ÏÑ± Î¨∏Ï†ú",
            root_cause="ÏãúÏä§ÌÖú Íµ¨ÏÑ± Î∞è Î™®ÎãàÌÑ∞ÎßÅ Î∂ÄÏ°±",
            confidence=0.60,
            suggested_actions=[
                "ÏãúÏä§ÌÖú Î°úÍ∑∏ ÏÉÅÏÑ∏ Î∂ÑÏÑù",
                "Î¶¨ÏÜåÏä§ ÏÇ¨Ïö©Îüâ Î™®ÎãàÌÑ∞ÎßÅ",
                "ÏÑ§Ï†ï Í≤ÄÌÜ† Î∞è ÏµúÏ†ÅÌôî",
                "ÏûêÎèô Î≥µÍµ¨ Î©îÏª§ÎãàÏ¶ò Íµ¨Ï∂ï"
            ]
        )
    
    def generate_demo_report(self) -> Dict[str, Any]:
        """Îç∞Î™® Î≥¥Í≥†ÏÑú ÏÉùÏÑ±"""
        report = {
            'demo_info': {
                'title': 'COSMOS AIOps Îç∞Î™®',
                'timestamp': datetime.now().isoformat(),
                'duration_minutes': 5
            },
            'statistics': self.stats,
            'logs_processed': len(self.processed_logs),
            'alerts_generated': len(self.alerts),
            'noise_suppression_rate': (
                self.stats['noise_reduced'] / self.stats['alerts_generated'] * 100
                if self.stats['alerts_generated'] > 0 else 0
            ),
            'components_affected': list(set(alert.component for alert in self.alerts)),
            'severity_distribution': {
                'CRITICAL': len([a for a in self.alerts if a.severity == 'CRITICAL']),
                'HIGH': len([a for a in self.alerts if a.severity == 'HIGH']),
                'MEDIUM': len([a for a in self.alerts if a.severity == 'MEDIUM']),
                'LOW': len([a for a in self.alerts if a.severity == 'LOW'])
            }
        }
        
        return report
    
    def run_complete_demo(self, log_count: int = 100) -> Dict[str, Any]:
        """Ï†ÑÏ≤¥ Îç∞Î™® Ïã§Ìñâ"""
        print("üåü COSMOS AIOps Îç∞Î™® ÏãúÏä§ÌÖú ÏãúÏûë")
        print("=" * 60)
        print("üìã Îç∞Î™® ÏãúÎÇòÎ¶¨Ïò§: Î°úÍ∑∏ ÏûÖÎ†• ‚Üí Í≤ΩÎ≥¥ ÏÜåÏùå ÏñµÏ†ú ‚Üí 3WHY ÏÑ§Î™Ö Ï∂úÎ†•")
        print("=" * 60)
        
        start_time = time.time()
        
        # 1. ÏÉòÌîå Î°úÍ∑∏ ÏÉùÏÑ±
        print("\nüìù 0Îã®Í≥Ñ: ÏÉòÌîå Î°úÍ∑∏ ÏÉùÏÑ±")
        logs = self.generate_sample_logs(log_count)
        print(f"‚úÖ {len(logs)}Í∞ú ÏÉòÌîå Î°úÍ∑∏ ÏÉùÏÑ± ÏôÑÎ£å")
        
        # 2. Î°úÍ∑∏ ÌååÏã±
        parsed_logs = self.parse_logs(logs)
        
        # 3. Ïù¥ÏÉÅ ÌÉêÏßÄ
        anomalies = self.detect_anomalies(parsed_logs)
        
        # 4. Í≤ΩÎ≥¥ ÏÉùÏÑ±
        alerts = self.generate_alerts(anomalies)
        
        # 5. ÏÜåÏùå ÏñµÏ†ú
        filtered_alerts = self.suppress_noise(alerts)
        
        # 6. 3WHY Î∂ÑÏÑù (ÏÉÅÏúÑ 3Í∞ú Í≤ΩÎ≥¥Îßå)
        top_alerts = sorted(filtered_alerts, key=lambda x: x.confidence, reverse=True)[:3]
        why_analyses = []
        
        for alert in top_alerts:
            analysis = self.perform_3why_analysis(alert)
            why_analyses.append(analysis)
        
        # 7. Î≥¥Í≥†ÏÑú ÏÉùÏÑ±
        duration = (time.time() - start_time) * 1000
        report = self.generate_demo_report()
        report['demo_info']['duration_ms'] = duration
        report['why_analyses'] = [
            {
                'alert_id': alert.id,
                'analysis': {
                    'primary_why': analysis.primary_why,
                    'secondary_why': analysis.secondary_why,
                    'tertiary_why': analysis.tertiary_why,
                    'root_cause': analysis.root_cause,
                    'confidence': analysis.confidence,
                    'suggested_actions': analysis.suggested_actions
                }
            }
            for alert, analysis in zip(top_alerts, why_analyses)
        ]
        
        # 8. ÏµúÏ¢Ö Í≤∞Í≥º Ï∂úÎ†•
        print("\nüìä === Îç∞Î™® Í≤∞Í≥º ÏöîÏïΩ ===")
        print("=" * 40)
        print(f"‚è±Ô∏è Ï¥ù ÏÜåÏöîÏãúÍ∞Ñ: {duration:.1f}ms")
        print(f"üìù Ï≤òÎ¶¨Îêú Î°úÍ∑∏: {report['logs_processed']}Í∞ú")
        print(f"üö® ÏÉùÏÑ±Îêú Í≤ΩÎ≥¥: {report['alerts_generated']}Í∞ú")
        print(f"üîá ÏÜåÏùå ÏñµÏ†úÏú®: {report['noise_suppression_rate']:.1f}%")
        print(f"üéØ 3WHY Î∂ÑÏÑù: {len(why_analyses)}Í∞ú")
        
        print(f"\nüèÜ Îç∞Î™® ÏÑ±Í≥µ! COSMOS AIOps ÏãúÏä§ÌÖúÏù¥ Ï†ïÏÉÅ ÏûëÎèôÌï©ÎãàÎã§.")
        
        return report

def main():
    """Î©îÏù∏ Ïã§Ìñâ Ìï®Ïàò"""
    demo = COSMOSAIOpsDemo()
    report = demo.run_complete_demo(log_count=50)  # ÏûëÏùÄ Í∑úÎ™®Î°ú ÌÖåÏä§Ìä∏
    
    # JSON Î¶¨Ìè¨Ìä∏ Ï†ÄÏû•
    with open('COSMOS_Unified/aiops_demo_report.json', 'w', encoding='utf-8') as f:
        json.dump(report, f, ensure_ascii=False, indent=2, default=str)
    
    print(f"\nüìÑ ÏÉÅÏÑ∏ Î¶¨Ìè¨Ìä∏Í∞Ä 'aiops_demo_report.json'Ïóê Ï†ÄÏû•ÎêòÏóàÏäµÎãàÎã§.")
    
    return report

if __name__ == "__main__":
    main()
